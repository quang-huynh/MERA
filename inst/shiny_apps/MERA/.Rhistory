0.4*180
shiny::runApp('C:/Users/tcar_/Dropbox/MSC_DLMtool_App/App')
runApp('C:/GitHub/FRAME/inst/shiny_apps/FRAME')
setwd("C:/Users/tcar_/Dropbox/abft-mse")
setwd("C:/Users/tcarruth/Dropbox/abft-mse")
# --- Source MSE functions and objects ------
library(ABTMSE)
# --- Define dimensions ------
Base<-new('OMI')
Base@Date<-as.character(Sys.time())
Base@Author<-"T. Carruthers (t.carruthers@oceans.ubc.ca)"
Base@Notes<-"This object serves as a framework for populating the various Trial Specifications"
Base@PrimarySource<-"ICCAT Bluefin assessment data preparatory meeting, July 2017"
Base@years<-years<-c(1965,2016)   #c(1960,2014)
Base@Hyears<-Hyears<-c(1864,1964) #c(1864,1959)
source("RScripts/Data processing/Area definitions.r") # Creates objects: AreaNames, AreaDefs
Base@areas<-areas<-      c("GOM_7","WATL_7","GSL_7","SATL_7", "NATL_7","EATL_7","MED_7")
Base@areanams<-areanams<-c("GOM",  "WATL",  "GSL",  "SATL",   "NATL",  "EATL",  "MED")
Base@area_defs<-new('list')
for(i in 1:length(Base@areas))Base@area_defs[[i]]<-AreaDefs[[match(areas[i],AreaNames)]]
Base@lenbins<-(1:16)*25         #Base@lenbins<-(0:30)*12.5                   # 25 cm length bins
nlen<-length(Base@lenbins)-1
Base@mulen<-(Base@lenbins[1:nlen]+Base@lenbins[2:(nlen+1)])/2
# --- Assign known dimensions ------
Base@nHy<-as.integer(Hyears[2]-Hyears[1]+1)       # No. historical years
Base@ny<-as.integer(years[2]-years[1]+1)          # No. years
Base@ns<-as.integer(4)                            # No. subyears
Base@np<-as.integer(2)                            # No. stocks
Base@na<-as.integer(35)                           # No. ages
Base@nr<-as.integer(length(areas))                # No. areas
Base@nf<-as.integer(length(Base@Fleets$name)+1)   # No. fleets
Base@nl<-as.integer(nlen)
Base@Ilencat<-array(c(2,5,4,6,7,Base@nl,1,5,7,Base@nl),c(Base@np,5))
# --- Recapture indexing by subyear
Base@nRPT<-as.integer(2) # recaptures are only calculated in consecutive timesteps
temp<-rep(1:Base@ns,ceiling(Base@nRPT/Base@ns)+Base@ns)
Base@RPTind<-array(NA,c(Base@ns,Base@nRPT))
for(ss in 1:Base@ns)Base@RPTind[ss,]<-temp[ss:(ss+Base@nRPT-1)]
Base@sdur<-rep(1/Base@ns,Base@ns) # the duration of each subyear - we make these equal
Base@nydist<-as.integer(10)
# --- (c) Create ALK ------
Base@lwa<-c(2.95*10^-5,1.96*10^-5)   # length-weight conversion w=al^b
Base@lwb<-c(2.899,3.009)             # length-weight conversion w=al^b
Base@A2<-c(NA,34)        # Richards growth curve
Base@L1<-c(NA,33.0)      # Richards growth curve
Base@L2<-c(NA,270.6)     # Richards growth curve
Base@K<-c(0.093,0.22)    # Richards / von B growth curve
Base@p<-c(NA,-0.12)       # Richards growth curve
Base@t0<-c(-0.97,NA)
Base@Linf<-c(318.85,NA)
Base@Lvar_a<-c(0.06,0.06)
Base@Lvar_b<-c(5.84,5.84)
source("RScripts/Data processing/iALK.r") # returns len_age wt_age iALK
Base@iALK<-iALK
Base@wt_age<-wt_age
Base@len_age<-len_age
# Fecundity / maturity / recruitment / mortality
#   Age      1  2  3  4     5    6  7  8  9  10 11 12 13 14 15 16 17 18+
mat<-array(c(0, 0, 0.25, 0.5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,rep(1,Base@na-18)),c(Base@na,Base@np))
Base@mat<-array(t(mat),c(Base@np,Base@na,Base@ny))
Base@Fec<-Base@mat[,,1]*Base@wt_age[,,1]
Base@nSR=4 # now many recruitments are estimated
Base@SRminyr=c(Base@years[1],1988,Base@years[1],1975)-Base@years[1]+1 # starting year of each recruitment
Base@SRmaxyr=c(1987,Base@years[2],1974,Base@years[2])-Base@years[1]+1 # end year of each recruitment
Base@SRp=c(1,1,2,2) # which stock
Base@SRpar=c(0.98, 0.98, 0.6, 0.9) # what steepness
Base@SRtype=c("BH","BH","BH","BH")
Base@nRDs<-rep(1,4)
RDts<-array(4,c(Base@np,Base@ny))
RDno<-array(1,c(Base@np,Base@ny))
yblock<-2 # the duration of recruitment deviation blocks
for(rd in 1:Base@nSR){
RDts[Base@SRp[rd],Base@SRminyr[rd]:Base@SRmaxyr[rd]]=rd
tempvec<-rep(1:100,each=yblock)[1:(Base@SRmaxyr[rd]-Base@SRminyr[rd]+1)]
RDno[Base@SRp[rd],Base@SRminyr[rd]:Base@SRmaxyr[rd]]=tempvec
Base@nRDs[rd]<-max(tempvec)
}
Base@RDno=RDno
Base@RDts=RDts
Base@spawns<-c(2,2)
Base@canspawn<-matrix(c(0,0,0,0,0,0,1,  1,1,0,0,0,0,0),ncol=Base@np) # matrix of spawning areas 1=can spawn
#   Age             1      2     3     4    5      6    7     8     9     10    11    12    13    14   15   16   17  18+
Base@Ma<-t(array(c(0.38, 0.30, 0.24, 0.20, 0.18, 0.16, 0.14, 0.13, 0.12, 0.12, 0.11, 0.11, 0.11, 0.1, 0.1, 0.1, 0.1, 0.1,rep(0.1,Base@na-18)),c(Base@na,Base@np)))
surv<-exp(-t(apply(cbind(c(0,0),Base@Ma[,1:(Base@na-1)]),1,cumsum)))
Base@SSBpR<-apply(surv*Base@Fec,1,sum)+surv[,Base@na]*exp(-Base@Ma[,Base@na])/(1-exp(-Base@Ma[,Base@na]))*Base@Fec[,Base@na]
Cobs<-write.csv("data/ICCAT_2019/Cobs.csv")
Cobs<-read.csv("data/ICCAT_2019/Cobs.csv")
head(Cobs)
apply(Cobs,2,min)
years[1]
Cobs<-Cobs[Cobs$Year>=years[1],]
Cobs
apply(Cobs,2,min)
Base@Cobs<-as.matrix(Cobs)
Base@nCobs<-nrow(Cobs)
source("Rscripts/Data processing/Master index.r") # returns list MI: MI[[1]] 0% efficiency increase MI[[2]] 2% efficiency increase MI[[3]] minus MA TP plus CAN LL 0% efficiency increase MI[[4]] minus MA TP plus CAN LL 2% efficiency increase
Base@RAI=MI[[1]]
source("RScripts/Data processing/CATDIS.r") # returns Cobs in the right format
source("Rscripts/Data processing/Master index.r") # returns list MI: MI[[1]] 0% efficiency increase MI[[2]] 2% efficiency increase MI[[3]] minus MA TP plus CAN LL 0% efficiency increase MI[[4]] minus MA TP plus CAN LL 2% efficiency increase
Base@RAI=MI[[1]]
source("Rscripts/Data processing/Partial Fs.r") # returns CPUEobs
Base@nE<-Base@nf # same number of cpue indices (if not using master index) as fleets
Base@nEobs<-nrow(Eobs)
Base@Eobs<-Eobs
head(Base@Cobs)
Cobs<-read.csv("data/ICCAT_2019/Cobs.csv")
Cobs<-Cobs[Cobs$Year>=years[1],]
Cobs$Year<-Cobs$Year-Years[1]+1
Cobs<-read.csv("data/ICCAT_2019/Cobs.csv")
Cobs<-Cobs[Cobs$Year>=years[1],]
Cobs$Year<-Cobs$Year-years[1]+1
Base@Cobs<-as.matrix(Cobs)
Base@nCobs<-nrow(Cobs)
# --- (e) Calculate master indices ------
source("Rscripts/Data processing/Master index.r") # returns list MI: MI[[1]] 0% efficiency increase MI[[2]] 2% efficiency increase MI[[3]] minus MA TP plus CAN LL 0% efficiency increase MI[[4]] minus MA TP plus CAN LL 2% efficiency increase
Base@RAI=MI[[1]]
# --- (f) Calculate partial F's ------
source("Rscripts/Data processing/Partial Fs.r") # returns CPUEobs
runApp('C:/GitHub/MERA/inst/shiny_apps/MERA')
