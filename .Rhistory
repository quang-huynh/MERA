ind<-c(close,close+(x[close]<xlev)*2-1)
ind <- ind[ind <= length(x)]
if (length(ind)==1) ind <- c(ind, ind-1)
if (min(ind)==0) ind <- 1:2
ind<-ind[order(ind)]
pos<-(xlev-x[ind[1]])/(x[ind[2]]-x[ind[1]])
max(1,y[ind[1]]+pos*(y[ind[2]]-y[ind[1]]))
}
load(paste0(getwd(),"/Data/Raw/SOO/SooN.Rdata"))
load(paste0(getwd(),"/Data/Raw/SOO/pE.Rdata"))
SOOg<-pE
SOO<-read.csv(paste0(getwd(),"/Data/ICCAT_2019/Joint East West Mixing Data 15042019.csv"),header=T)[,c(5,6,10,11,13,15,16)]
SOO_old<-read.csv(paste0(getwd(),"/Data/Raw/SOO/Joint East West mixing data updated 06072018 with geneticID.csv"),header=T,sep=";")[,c(5,6,10,11,13,15,16)]
names(SOO)<-c("Year","Length","age","Prob.East","BFT_Area","Quarter","Method")
SOO<-subset(SOO,SOO$Year>(Base@years[1]-1)&SOO$Year<(Base@years[2]+1))
SOO$Year<-SOO$Year-Base@years[1]+1
print(paste("Total SOO assigments:",nrow(SOO)))
print(paste("SOO assignments missing age:",sum(is.na(SOO$age))))
print(paste("SOO assignments missing age and length:",sum(is.na(SOO$age)&is.na(SOO$Length))))
meths<-unique(SOO$Method)
org<-c("CAR", "E_ATL","E_MED",  "GOM","GSL","NC_ATL", "NE_ATL", "SC_ATL", "SE_ATL", "W_ATL",  "W_MED")
nu<-c(   2,     6,      7,       1,    3,     5,       5,        4,         4,      2,        7)#
nu_nam<-c("GOM","WATL","GSL","SATL","NATL","EATL","MED")
SOO$BFT_Area<-nu[match(SOO$BFT_Area,org)]
# Fill missing ages with cohort sliced ages using covariate length data
cond_fill<-is.na(SOO$age)&!is.na(SOO$Length)
ind<-(1:nrow(SOO))[cond_fill]
Lage<-apply(Base@len_age[,,1],2,mean)
Lengths<-as.numeric(as.character(SOO$Length[cond_fill]))
for(i in 1:length(Lengths))  SOO$age[ind[i]]<-floor(LinInterp(x=Lage,y=1:length(Lage),xlev=Lengths[i]))
print(paste("SOO assignments missing age after imputation:",sum(is.na(SOO$age))))
# Remove entries missing at least one required field
SOO<-SOO[,c(1,3,4,5,6,7)] # lose the length data
anyna<-function(x)sum(is.na(x))==0
keep<-apply(SOO,1,anyna)
print(paste("SOO assignments with all required covariates:",sum(keep)))
SOO<-SOO[keep,]
# Convert to age class
SOO$age[SOO$age>Base@na]<-Base@na
SOO$age<-ma[1,SOO$age] # age class
# define signature distributions and optimization function
res<-0.05
breaks<-seq(0,1,by=res)
# Otolith Chemistry
pE<-hist(SOO$Prob.East[SOO$BFT_Area==7 & SOO$Method=="Otolith Chemistry"],breaks=breaks)$density
pW<-hist(SOO$Prob.East[SOO$BFT_Area==1 & SOO$Method=="Otolith Chemistry"],breaks=breaks)$density
pE<-pE/sum(pE)
pW<-pW/sum(pW)
# Genetics
pEg<-hist(SOOg$probMED[SOOg$origin=="MED"]/100,breaks=breaks)$density
pWg<-hist(SOOg$probMED[SOOg$origin=="GOM"]/100,breaks=breaks)$density
pEg<-pEg/sum(pEg)
pWg<-pWg/sum(pWg)
getSOO<-function(x,strata,SOO,pE,pW,breaks,plot=F,type='Otolith Chemistry'){
cond<-SOO$Method==type & SOO$Year==strata[x,1] &
SOO$age==strata[x,2] & SOO$BFT_Area==strata[x,3] & SOO$Quarter == strata[x,4]
pM<-hist(SOO$Prob.East[cond],breaks=breaks,plot=F)$density
pM<-pM/sum(pM)
if(plot)barplot(pM,border="white",axes=F)
temp<-optim(c(0,-1),SOOopt,hessian=T,pM=pM,pE=pE,pW=pW)
probElogit<-temp$par[1]
probE=exp(probElogit)/(1+exp(probElogit))
SElogit<-solve(temp$hessian)[1,1]^0.5
SE<-exp(SElogit)/(1+exp(SElogit))
LB=probElogit-(1.96*SElogit)
UB=probElogit+(1.96*SElogit)
LB<-exp(LB)/(1+exp(LB))
UB<-exp(UB)/(1+exp(UB))
sig=exp(temp$par[2])
#pu = (sqrt(probE) + sig)^2
#pl = (sqrt(probE) - sig)^2
#SE<-(pu-pl)/2
if(plot){
#legend('topleft',legend=c(paste0("y=",strata[x,1]),paste0("age=",strata[x,2])),cex=0.8,bty='n')
#legend('top',legend=c(paste0("ar=",strata[x,3]),paste0("q=",strata[x,4])),cex=0.8,bty='n')
pred<-(pE*probE)+(pW*(1-probE))
pred<-(pred/sum(pred))
breakmu<-((breaks[1:(length(breaks)-1)]+breaks[2:length(breaks)])/2)*24
lines(breakmu,pred,col="#ff00ff80",lwd=3)
mtext(paste0("R=",round(probE*100,0),"% (",nu_nam[strata[x,3]],", Q",strata[x,4],")"),3,line=-0.04,cex=0.6)
legend('top',legend=paste0("[",round(LB*100,0),"%,",round(UB*100,0),"%]"),cex=0.8,bty='n')
}
c(probE,SE,probElogit,SElogit)
}
SOOopt<-function(par,pM,pE,pW){
rat=exp(par[1])/(1+exp(par[1]))
sig=exp(par[2])
pMexp<-rat*pE+(1-rat)*pW
pMexp<-pMexp/sum(pMexp)
#sig<-sd((sqrt(pM)-sqrt(pMexp)))
obj<-sum(log(sig) + (sqrt(pM)-sqrt(pMexp))^2/(2*sig^2))
obj<-obj-dnorm(par[1],0,sd=5,log=T)
return(obj)
}
SOO_OC<-SOO[SOO$Method=='Otolith Chemistry' & !(SOO$BFT_Area%in%c(1,7)),]
strata1<-aggregate(rep(1,nrow(SOO_OC)),by=list(SOO_OC$Year,SOO_OC$age,SOO_OC$BFT_Area,SOO_OC$Quarter),FUN=sum)
strata<-strata1[strata1$x>5,]
par(mfrow=c(18,6),mai=c(0.01,0.01,0.2,0.01))
out<-sapply(1:nrow(strata),getSOO,strata=strata,SOO=SOO,pE=pE,pW=pW,breaks=breaks,plot=F)
ord<-order(out[1,])
out<-sapply(ord[2:length(ord)],getSOO,strata=strata,SOO=SOO,pE=pE,pW=pW,breaks=breaks,plot=T)
suppressWarnings({
out<-sapply(1:nrow(strata),getSOO,strata=strata,SOO=SOO,pE=pE,pW=pW,breaks=breaks,plot=F)
})
SOO_G<-SOO[SOO$Method=='Genetics' & !(SOO$BFT_Area%in%c(1,7)),]
strata1<-aggregate(rep(1,nrow(SOO_G)),by=list(SOO_G$Year,SOO_G$age,SOO_G$BFT_Area,SOO_G$Quarter),FUN=sum)
strata_g<-strata1[strata1$x>5,]
par(mfrow=c(6,5),mai=c(0.01,0.01,0.2,0.01))
out_g<-sapply(1:nrow(strata_g),getSOO,strata=strata_g,SOO=SOO,pE=pEg,pW=pWg,breaks=breaks,plot=F,type="Genetics")
ord<-order(out_g[1,])
out_g<-sapply(ord[2:length(ord)],getSOO,strata=strata_g,SOO=SOO,pE=pEg,pW=pWg,breaks=breaks,plot=T,type="Genetics")
suppressWarnings({
out_g<-sapply(1:nrow(strata_g),getSOO,strata=strata_g,SOO=SOO,pE=pE,pW=pW,breaks=breaks,plot=F,type="Genetics")
})
cond<-(out[1,]^0.5-out[2,])<0
redface=sum(cond)
redface
SOOobs_o<-cbind(strata[,c(2,1,4,3,5)],t(out[3:4,]),rep(1,nrow(strata)))
SOOobs_g<-cbind(strata_g[,c(2,1,4,3,5)],t(out_g[3:4,]),rep(2,nrow(strata_g)))
names(SOOobs_o)<-names(SOOobs_g)<-c("a","y","s","r","N","probE","SE","Type")
add_Genetics
if(add_Genetics){
SOOobs<-rbind(SOOobs_o,SOOobs_g)
}else{
SOOobs<-SOOobs_o
}
#p a y s r N
plot(SOOobs[,5],SOOobs[,7])
plot(SOOobs[,4],SOOobs[,6])
head(SOOobs)
gom_g_sig<-SOOg$probMED[SOOg$origin=="GOM"]/100
gom_g_sig
SOO_AM<-aggregate(rep(1,nrow(SOO)),by=list(SOO$Method,SOO$BFT_Area),sum)
SOO_AM_mat<-matrix(0,nrow=2,ncol=7)
SOO_AM_mat[cbind(
as.numeric(match(SOO_AM$Group.1,meths)),
as.numeric(SOO_AM$Group.2))] <- SOO_AM$x
SOO_AM_mat<-data.frame(SOO_AM_mat,row.names = meths)
names(SOO_AM_mat)<-nu_nam
SOO_AM_mat
SOOobs<-as.matrix(SOOobs)
save(SOOobs,file=paste(getwd(),"/Data/Processed/Conditioning/SOOobs",sep=""))
Base@nSOOobs<-nrow(SOOobs)
ma<-array(rep(c(rep(1,3),rep(2,5),rep(3,Base@na-8)),each=Base@np),c(Base@np,Base@na))
nma<-max(ma)
add_Genetics=T
summary=F
testSOO=F
source("Rscripts/Data processing/SOO 2019.r")
Base@nSOOobs<-nrow(SOOobs)
Base@SOOobs<-SOOobs
Base@nf
fnam
fnams
CPUEdat<-read.csv(file=paste(getwd(),"/data/ICCAT_2019/CPUE_indices compiled_2019OM.csv",sep=""))
CPUEdat
CPUEdat<-read.csv(file=paste(getwd(),"/data/ICCAT_2019/CPUE_indices compiled_2019OM.csv",sep=""))
head(CPUEdat)
aggregate(rep(1,nrow(CPUEdat)),by=list(CPUEdat$Fleet,CPUEdat$Name))
aggregate(rep(1,nrow(CPUEdat)),by=list(CPUEdat$Fleet,CPUEdat$Name),sum)
#
Base@nsel<-Base@nf
Base@seltype<-rep(3,Base@nf) #c(3,3,2,3,2,2,3,3,2,3,3,3,3)#rep(3,Base@nf) # all fleets have thompson (potentially) dome-shaped selectivity except the combined other fleet
Base@seltype[2]<-2
#Base@seltype[(1:length(Fleets$name))[Fleets$name%in%c("LLOTH","RRCan","RRUSA")]]<-2 # set longline to asymptotic
#Base@seltype[length(Base@seltype)]<-2
Base@selind<-1:Base@nf # No selectivity mirroring - selectivities correspond to fleets
Base@ratiolim<-c(0.1,0.4) # limits on the logistic slope paramter relative to position of inflection point
Base@infleclim<-c(4,15) # limits on the location of the inflection point (age)
Base@movtype<-as.integer(1)
source("Rscripts/Data processing/Movement definitions.r") # returns movind and mov1
Base@nMP<-nrow(movind)+Base@ns*Base@np*Base@nma
Base@nmovind<-nrow(movind)
Base@movind<-movind
Base@nmov1<-nrow(mov1)
Base@mov1<-mov1
source("Rscripts/Data processing/Movement exclusions.r") # returns MovExc
Base@nMovExc<-nrow(MovExc)
Base@MovExc<-MovExc
Base@BSfrac<-array(0.5,c(Base@np,Base@ns))
CPUEdat<-read.csv(file=paste(getwd(),"/data/ICCAT_2019/CPUE_indices compiled_2019OM.csv",sep=""))
aggregate(rep(1,nrow(CPUEdat)),by=list(CPUEdat$Fleet,CPUEdat$Name),sum)
#                1       2        3         4         5         6            7          8         9      10      11       12
Fleets<-new('list') # note you must put ALL flag types ahead of specific fleet types of same gear - sequential fleet assignment
Fleets$name<-  c("LLOTH","LLJPN",paste("flt",3:17,sep="_"))
# --- Set working directory ------
setwd("C:/Users/tcar_/Dropbox/abft-mse")
setwd("C:/Users/tcarruth/Dropbox/abft-mse")
# --- Source MSE functions and objects ------
library(ABTMSE)
# --- Define dimensions ------
Base<-new('OMI')
Base@Date<-as.character(Sys.time())
Base@Author<-"T. Carruthers (t.carruthers@oceans.ubc.ca)"
Base@Notes<-"This object serves as a framework for populating the various Trial Specifications"
Base@PrimarySource<-"ICCAT Bluefin assessment data preparatory meeting, July 2017"
Base@years<-years<-c(1965,2016)   #c(1960,2014)
Base@Hyears<-Hyears<-c(1864,1964) #c(1864,1959)
# --- (a) Create some prespecified areas (polygons with lons and lats) ------
source("RScripts/Data processing/Area definitions.r") # Creates objects: AreaNames, AreaDefs
# --- Define areas ------
Base@areas<-areas<-      c("GOM_7","WATL_7","GSL_7","SATL_7", "NATL_7","EATL_7","MED_7")
Base@areanams<-areanams<-c("GOM",  "WATL",  "GSL",  "SATL",   "NATL",  "EATL",  "MED")
Base@area_defs<-new('list')
for(i in 1:length(Base@areas))Base@area_defs[[i]]<-AreaDefs[[match(areas[i],AreaNames)]]
# --- (b) Define fleets ------
source("Rscripts/Data processing/Define fleets 2019.r") # Returns a list Fleets
Base@Fleets<-Fleets
Base@lenbins<-(1:16)*25         #Base@lenbins<-(0:30)*12.5                   # 25 cm length bins
nlen<-length(Base@lenbins)-1
Base@mulen<-(Base@lenbins[1:nlen]+Base@lenbins[2:(nlen+1)])/2
# --- Assign known dimensions ------
Base@nHy<-as.integer(Hyears[2]-Hyears[1]+1)       # No. historical years
Base@ny<-as.integer(years[2]-years[1]+1)          # No. years
Base@ns<-as.integer(4)                            # No. subyears
Base@np<-as.integer(2)                            # No. stocks
Base@na<-as.integer(35)                           # No. ages
Base@nr<-as.integer(length(areas))                # No. areas
Base@nf<-as.integer(length(Base@Fleets$name)+1)   # No. fleets
Base@nl<-as.integer(nlen)
# --- The index length category set up ------
Base@Ilencat<-array(c(2,5,4,6,7,Base@nl,1,5,7,Base@nl),c(Base@np,5))
# --- Recapture indexing by subyear
Base@nRPT<-as.integer(2) # recaptures are only calculated in consecutive timesteps
temp<-rep(1:Base@ns,ceiling(Base@nRPT/Base@ns)+Base@ns)
Base@RPTind<-array(NA,c(Base@ns,Base@nRPT))
for(ss in 1:Base@ns)Base@RPTind[ss,]<-temp[ss:(ss+Base@nRPT-1)]
# --- Misc ------
Base@sdur<-rep(1/Base@ns,Base@ns) # the duration of each subyear - we make these equal
Base@nydist<-as.integer(10)
# --- (c) Create ALK ------
Base@lwa<-c(2.95*10^-5,1.96*10^-5)   # length-weight conversion w=al^b
Base@lwb<-c(2.899,3.009)             # length-weight conversion w=al^b
Base@A2<-c(NA,34)        # Richards growth curve
Base@L1<-c(NA,33.0)      # Richards growth curve
Base@L2<-c(NA,270.6)     # Richards growth curve
Base@K<-c(0.093,0.22)    # Richards / von B growth curve
Base@p<-c(NA,-0.12)       # Richards growth curve
Base@t0<-c(-0.97,NA)
Base@Linf<-c(318.85,NA)
Base@Lvar_a<-c(0.06,0.06)
Base@Lvar_b<-c(5.84,5.84)
source("RScripts/Data processing/iALK.r") # returns len_age wt_age iALK
Base@iALK<-iALK
Base@wt_age<-wt_age
Base@len_age<-len_age
# Fecundity / maturity / recruitment / mortality
#   Age      1  2  3  4     5    6  7  8  9  10 11 12 13 14 15 16 17 18+
mat<-array(c(0, 0, 0.25, 0.5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,rep(1,Base@na-18)),c(Base@na,Base@np))
Base@mat<-array(t(mat),c(Base@np,Base@na,Base@ny))
Base@Fec<-Base@mat[,,1]*Base@wt_age[,,1]
Base@nSR=4 # now many recruitments are estimated
Base@SRminyr=c(Base@years[1],1988,Base@years[1],1975)-Base@years[1]+1 # starting year of each recruitment
Base@SRmaxyr=c(1987,Base@years[2],1974,Base@years[2])-Base@years[1]+1 # end year of each recruitment
Base@SRp=c(1,1,2,2) # which stock
Base@SRpar=c(0.98, 0.98, 0.6, 0.9) # what steepness
Base@SRtype=c("BH","BH","BH","BH")
Base@nRDs<-rep(1,4)
RDts<-array(4,c(Base@np,Base@ny))
RDno<-array(1,c(Base@np,Base@ny))
yblock<-2 # the duration of recruitment deviation blocks
for(rd in 1:Base@nSR){
RDts[Base@SRp[rd],Base@SRminyr[rd]:Base@SRmaxyr[rd]]=rd
tempvec<-rep(1:100,each=yblock)[1:(Base@SRmaxyr[rd]-Base@SRminyr[rd]+1)]
RDno[Base@SRp[rd],Base@SRminyr[rd]:Base@SRmaxyr[rd]]=tempvec
Base@nRDs[rd]<-max(tempvec)
}
Base@RDno=RDno
Base@RDts=RDts
Base@spawns<-c(2,2)
Base@canspawn<-matrix(c(0,0,0,0,0,0,1,  1,1,0,0,0,0,0),ncol=Base@np) # matrix of spawning areas 1=can spawn
#   Age             1      2     3     4    5      6    7     8     9     10    11    12    13    14   15   16   17  18+
Base@Ma<-t(array(c(0.38, 0.30, 0.24, 0.20, 0.18, 0.16, 0.14, 0.13, 0.12, 0.12, 0.11, 0.11, 0.11, 0.1, 0.1, 0.1, 0.1, 0.1,rep(0.1,Base@na-18)),c(Base@na,Base@np)))
surv<-exp(-t(apply(cbind(c(0,0),Base@Ma[,1:(Base@na-1)]),1,cumsum)))
Base@SSBpR<-apply(surv*Base@Fec,1,sum)+surv[,Base@na]*exp(-Base@Ma[,Base@na])/(1-exp(-Base@Ma[,Base@na]))*Base@Fec[,Base@na]
Cobs<-read.csv("data/ICCAT_2019/Cobs.csv")
Cobs<-Cobs[Cobs$Year>=years[1],]
Cobs$Year<-Cobs$Year-years[1]+1
Cobs$Catch<-Cobs$Catch*1000 # tonnes to kg
Base@Cobs<-as.matrix(Cobs)
Base@nCobs<-nrow(Cobs)
Base@nf<-max(Cobs$Fleet)
source("Rscripts/Data processing/Master index.r") # returns list MI: MI[[1]] 0% efficiency increase MI[[2]] 2% efficiency increase MI[[3]] minus MA TP plus CAN LL 0% efficiency increase MI[[4]] minus MA TP plus CAN LL 2% efficiency increase
Base@RAI=MI[[1]]
# --- (f) Calculate partial F's ------
source("Rscripts/Data processing/Partial Fs.r") # returns CPUEobs
Base@nE<-Base@nf
Base@nEobs<-nrow(Eobs)
Base@Eobs<-Eobs
# --- (g) Process assessment indices ----
source("Rscripts/Data processing/Fishery indices.r") # returns CPUEqvec and CPUEobs in the right format
Base@nCPUEq<-max(CPUEobs$qNo)
Base@nCPUEobs<-nrow(CPUEobs)
Base@CPUEobs<-as.matrix(CPUEobs)
Base@CPUEnames<-CPUEnames
#CPUEup<-2# 10
#              "SPN_BB" "SPN_FR_BB" "MOR_SPN_TRAP" "MOR_POR_TRAP" "JPN_LL_Eatl_Med" "JPN_LL_NEAtl1" "JPN_LL_NEAtl2" "US_RR_66_114" "US_RR_115_144" "US_RR_177" "US_RR_145" "US_RR_195" "US_GOM_PLL1" "US_GOM_PLL2" "JPLL_GOM" "JPN_LL_West1" "JPN_LL_West2" "CAN GSL" "CAN SWNS"
#Base@CPUEwt <-c(1,       1,          1,             1,             1,               1,              CPUEup,          CPUEup,             1,              1,     CPUEup,          1,          1,       CPUEup,            1,    CPUEup*2,          CPUEup,         1/CPUEup,  1/CPUEup)
Base@CPUEwt <-rep(1,Base@nCPUEq)#c(1,       1,          1,             1,             1,               1,              CPUEup,          CPUEup,             1,              1,     CPUEup,          1,          1,       CPUEup,            1,    CPUEup*2,          CPUEup,         1/CPUEup,  1/CPUEup)
# --- (h) Calculate length sample data ------
source("Rscripts/Data processing/Length observations 2019.r") # returns CLobs
Base@nCLobs<-nrow(CLobs)
Base@CLobs<-as.matrix(CLobs)
# --- (i) Calculate historical catches ------
source("Rscripts/Data processing/Historical catches 2019.r") # returns HCobs
Base@HCobs<-HCobs # a 4D array y x s x a x  r
source("Rscripts/Data processing/FI indices 2019.r") # returns Iobs and Inames
Base@nI<-as.integer(max(Iobs[,5])) # number of series
Base@nIobs<-nrow(Iobs) # number of data
Base@Iobs<-Iobs   # y s r i type(biomass/ssb) index
Base@Inames<-Inames
#Iup<-2 #24
#          "FR_AER_SUV1" "FR_AER_SUV2" "MED_LAR_SUV" "CAN_ACO_SUV" "GOM_LAR_SUV" "GBYP_AER_SUV"
#Base@Iwt<-c(1,            1,            Iup,         Iup*2,            Iup*3,          1)
Base@Iwt<-rep(1,Base@nI)
# --- (k) PSAT tags ------
Base@nma<-as.integer(3)
Base@ma<-c(rep(1,4),rep(2,4),rep(3,Base@na-8))
Impute=FALSE # Do you want to use movement fingerprinting to identify more PSATs?
source("Rscripts/Data processing/PSAT.r") # returns a table of electronic tag tracks of known (PSAT) and unknown (PSAT2) stock of origin
Base@nPSAT<-nrow(PSAT)
Base@PSAT<-as.matrix(PSAT)
Base@nPSAT2<-as.integer(2)#nrow(PSAT2)
Base@PSAT2<-as.matrix(PSAT2[1:2,])#as.matrix(PSAT2)
# --- Conventional tags ------
Base@nTag<-as.integer(1) # currently this is placeholder for conventional tags that are ignored by M3
Base@Tag<-array(c(2,1,7,1,2,2,7,1,2,1),c(1,10))
# --- (l) Stock of origin observations ------
ma<-array(rep(c(rep(1,3),rep(2,5),rep(3,Base@na-8)),each=Base@np),c(Base@np,Base@na))
nma<-max(ma)
add_Genetics=T
summary=F
testSOO=F
source("Rscripts/Data processing/SOO 2019.r")
Base@nSOOobs<-nrow(SOOobs)
Base@SOOobs<-SOOobs
Base@nsel<-Base@nf
Base@seltype<-rep(3,Base@nf) #c(3,3,2,3,2,2,3,3,2,3,3,3,3)#rep(3,Base@nf) # all fleets have thompson (potentially) dome-shaped selectivity except the combined other fleet
Base@seltype[2]<-2
#Base@seltype[(1:length(Fleets$name))[Fleets$name%in%c("LLOTH","RRCan","RRUSA")]]<-2 # set longline to asymptotic
#Base@seltype[length(Base@seltype)]<-2
Base@selind<-1:Base@nf # No selectivity mirroring - selectivities correspond to fleets
Base@ratiolim<-c(0.1,0.4) # limits on the logistic slope paramter relative to position of inflection point
Base@infleclim<-c(4,15) # limits on the location of the inflection point (age)
Base@movtype<-as.integer(1)
source("Rscripts/Data processing/Movement definitions.r") # returns movind and mov1
Base@nMP<-nrow(movind)+Base@ns*Base@np*Base@nma
Base@nmovind<-nrow(movind)
Base@movind<-movind
Base@nmov1<-nrow(mov1)
Base@mov1<-mov1
source("Rscripts/Data processing/Movement exclusions.r") # returns MovExc
Base@nMovExc<-nrow(MovExc)
Base@MovExc<-MovExc
# --- BSfrac a prior on asymptotic stock mixing (not used in reference OMs) ---------
Base@BSfrac<-array(0.5,c(Base@np,Base@ns))
Base@CobsCV<-   rep(0.05,Base@nf)        # CV on seasonal catch observations by area
#                "SPN_BB" "SPN_FR_BB" "MOR_SPN_TRAP" "MOR_POR_TRAP" "JPN_LL_Eatl_Med" "JPN_LL_NEAtl1" "JPN_LL_NEAtl2" "US_RR_66_114" "US_RR_115_144" "US_RR_177" "US_RR_145" "US_RR_195" "US_GOM_PLL1" "US_GOM_PLL2" "JPLL_GOM" "JPN_LL_West1" "JPN_LL_West2" "CAN GSL" "CAN SWNS"
Base@CPUEobsCV<-c(0.5,     0.5,        0.4,           0.4,           0.35,             0.3,          0.35,           0.4,           0.4,            0.4,       0.4,          0.35,       0.4,         0.35,            0.35,       0.5,           0.4,           0.8,      0.7) # CV on seasonal CPUE observations by area
#              "FR_AER_SUV1" "FR_AER_SUV2" "MED_LAR_SUV" "CAN_ACO_SUV" "GOM_LAR_SUV" "GBYP_AER_SUV"
Base@IobsCV<-   c(0.3,          0.4,        0.5,          0.35,          0.2,          0.2)         # CV on fishery independent indices
Base@RDCV<-0.5/(Base@ny/(Base@ny/yblock))^0.5 # CV for penalty on recruitment deviations (if blocked this is Std. Err.)
Base@nSSBprior=1
Base@SSBprior = matrix(c(1,1,20000),nrow=1)      # dummy prior for SSB (some operating models use fractions of other model estimated current SSB)
Base@SSBCV=10                       # default is a very imprecise prior on SSB
Base@nDepprior=1
Base@Depprior = matrix(c(1,1,0.5),nrow=1)      # dummy prior for SSB (some operating models use fractions of other model estimated current SSB)
Base@DepCV=10                        # default is a very imprecise prior on SSB
Base@FCV=0.4                  # was 0.4        # Prior precision of season-area deviations around mean F
Base@movCV=1.2                 # was 1        # Prior precision of deviations from homogeneous movement
Base@selCV=0.8                        # Prior precision of selectivity parameters
Base@SSBincCV=0.01                    # Prior precision of SSB increase ratio
Base@R0diffCV=0.45                   #was 0.5  # Prior on diferrence in early and late R0 estimation (where applicable)
Base@BSfracCV=0.02
Base@nLHw<-as.integer(16)             # number of likelihood components that may be weighted
#                           (1 catch, 2 cpue, 3 FIindex, 4 Lcomp, 5 SOO, 6 PSAT, 7 PSAT2, 8 RecDev, 9 mov,  10 sel,  11 SRA, 12 SSB, 13 SSBinc, 14 Fmod, 15 R0diff, 16 BSfrac)",datfile,1,append=T)
Base@LHw<-          0.01*  c(0.4,     4,      140,       1/40,    600,   100,     0,       50,       1/10,   1,       0.0002,       0,      0,         75,    1000,      0) # SSB index for each population
#Base@LHw<-          0.01*  c(0.4,     4,      140,       1/40,    600,   90,     0,       50,       1/10,   1,       0.0002,       0,      0,         75,    1000,      0) # SSB index for each population
#Base@LHw<-          0.01*  c(0.4,     4,      70,        1/40,    600,   90,     0,       50,       1/10,   1,       0.0002,       0,      0,         25,    1000,      0) # SSB index for each population
# --- Initial Values ------
Base@muR_ini<-c(350*8,350)*5000
Base@sel_ini<-t(array(c(0,0,(1:4)/4,rep(1,Base@nl-6)),c(Base@nl,Base@nf)))
Base@selpar_ini<-t(array(c(-5,0,-1),c(3,Base@nf)))
Base@selpar_ini[match('LLJPN',Base@Fleets$name),]<- c(1,-1,99)# LL  - logistic - mode and sd are 0.26
Base@lnF_ini<-rep(log(0.001),nrow(Base@Cobs))
Base@lnRD_ini<-t(array(seq(-0.1,0.1,length.out=Base@ny),c(Base@ny,Base@np)))
Base@mov_ini<-tomt(array(1/Base@nr,c(Base@np,Base@ns,Base@na,Base@nr,Base@nr)))
Base@qCPUE_ini<-rep(1,Base@nCPUEq)
Base@qI_ini<-rep(1,Base@nI)
Base@D_ini<-c(0.1,0.1)#c(sum(Base@RAI[,2,Base@canspawn[,1]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,1]==1][1:3]),sum(Base@RAI[,2,Base@canspawn[,2]==1][(Base@ny-2):Base@ny])/sum(Base@RAI[,2,Base@canspawn[,2]==1][1:3]))# just for comparison with simulations
Base@complexRD<-as.integer(0)
Base@complexF<-as.integer(0)
Base@nF<-as.integer(1)
Base@MPind<-read.csv("Data/Processed/MP Indices/MP indices compiled assessment 2017.csv")
Base@nMPind<-nrow(Base@MPind)
Base@debug<-as.integer(0)
Base@verbose<-as.integer(1)
Base@datacheck<-as.integer(99999)
# Naming the Base operating model according to the various OM factors at level 1 -------
Base@Name<-"1AI"#paste(c("Base OM:",Names_Base),collapse=" ")
Base@OMfactors<-list("Prelim fits for DSB","", "")
# Save the base OMI  ------
OMI<-Base
M3write(OMI,OMdir=paste0(getwd(),"/M3"))  # Store this base operating model in the M3 directory
Base@nf
OM<-XL2OM("Cod_5ZJM_DFO.xlsx")
# recdevs
# --- cpars --------------------------------------------------------
yrs<-1978:2016
proyears<-OM@proyears
nyears<-length(yrs)
maxage<-OM@maxage
nsim<-OM@nsim
# get VPA selectivity and apical F
Fage<-read.csv("data/Fage.csv",header=T)
# Base model uses the 2-period M assumption
Fmat<-as.matrix(Fage[,2:ncol(Fage)])
#Fmat<-t(matrix(as.numeric(Fage[3,2:ncol(Fage)]),nrow=15)) # row 3 is the two period M model
sel<-Fmat
Fapical<-apply(sel,1,max)
sel<-sel/Fapical
nyearssel<-dim(sel)[1]# == 29 == (2008-1980+1)
nagesel<-dim(sel)[2] # == 14
V <- array(NA, dim = c(nsim, maxage, nyears + proyears))
# 1978-2016, ages 1 - 10
Vind2008<-as.matrix(expand.grid(1:nsim,1:nagesel,1:nyearssel))
V[Vind2008]<-sel[cbind(Vind2008[,3],Vind2008[,2])]
# 1978-2016, ages 11-20
Vindolder<-as.matrix(expand.grid(1:nsim,(nagesel+1):maxage,1:nyearssel))
V[Vindolder]<-V[cbind(Vindolder[,1],rep(10,nrow(Vindolder)),Vindolder[,3])]
# 2017-2056, ages 1-20
selrecent<-apply(V[1,,nyearssel+(-3:0)],1,mean) # recent selectivity is mean over last 4 years 2005-2008
selrecent<-selrecent/max(selrecent)
Vindrest<-as.matrix(expand.grid(1:nsim,1:maxage,(nyearssel+1):(nyears+proyears)))
V[Vindrest]<-selrecent[Vindrest[,2]]
# F index
Find<-array(rep(Fapical,each=nsim),c(nsim,nyears))
#M at age arrary
M_ageArray <- array(mean(OM@M), dim=c(nsim, maxage, nyears + proyears))
M2years<-1994:(2016+proyears)
M2ages<-6:20
M_ageArray[,M2ages,M2years-1978+1]<-0.8
recdevs<-read.csv('data/rec devs.csv',header=F)[,1]
procsd<-sd(recdevs)
procmu <- -0.5 * (procsd)^2  # adjusted log normal mean
AC<-acf(recdevs)$acf[2,1,1]
OM@Perr<-rep(procsd,2)
OM@AC=rep(AC,2)
Perr<-array(NA,c(nsim,nyears+proyears+maxage-1))
Perr<-matrix(rnorm(nsim*(maxage+nyears+proyears-1),rep(procmu,maxage+nyears+proyears-1),rep(procsd,maxage+nyears+proyears-1)),nrow=nsim)
Perr[,maxage+(0:(nyearssel-2))]<-rep(recdevs,each=nsim) # generate a bunch of simulations with uncertainty
for (y in 2:(maxage-1)) Perr[, y] <- AC * Perr[, y - 1] +   Perr[, y] * (1 - AC * AC)^0.5
for (y in maxage+(nyears:(nyears + proyears))-1) Perr[, y] <- AC * Perr[, y - 1] +   Perr[, y] * (1 - AC * AC)^0.5
Perr<-exp(Perr)
OM@cpars<-list(V=V,Find=Find,M_ageArray=M_ageArray,Perr=Perr)
# --- Create the OM document
OM@seed <- 1001
setwd("C:/GitHub/DLMDev/Case_Studies/Cod_5ZJM_DFO")
OM<-XL2OM("Cod_5ZJM_DFO.xlsx")
# recdevs
# --- cpars --------------------------------------------------------
yrs<-1978:2016
proyears<-OM@proyears
nyears<-length(yrs)
maxage<-OM@maxage
nsim<-OM@nsim
# get VPA selectivity and apical F
Fage<-read.csv("data/Fage.csv",header=T)
# Base model uses the 2-period M assumption
Fmat<-as.matrix(Fage[,2:ncol(Fage)])
#Fmat<-t(matrix(as.numeric(Fage[3,2:ncol(Fage)]),nrow=15)) # row 3 is the two period M model
sel<-Fmat
Fapical<-apply(sel,1,max)
sel<-sel/Fapical
nyearssel<-dim(sel)[1]# == 29 == (2008-1980+1)
nagesel<-dim(sel)[2] # == 14
V <- array(NA, dim = c(nsim, maxage, nyears + proyears))
# 1978-2016, ages 1 - 10
Vind2008<-as.matrix(expand.grid(1:nsim,1:nagesel,1:nyearssel))
V[Vind2008]<-sel[cbind(Vind2008[,3],Vind2008[,2])]
# 1978-2016, ages 11-20
Vindolder<-as.matrix(expand.grid(1:nsim,(nagesel+1):maxage,1:nyearssel))
V[Vindolder]<-V[cbind(Vindolder[,1],rep(10,nrow(Vindolder)),Vindolder[,3])]
# 2017-2056, ages 1-20
selrecent<-apply(V[1,,nyearssel+(-3:0)],1,mean) # recent selectivity is mean over last 4 years 2005-2008
selrecent<-selrecent/max(selrecent)
Vindrest<-as.matrix(expand.grid(1:nsim,1:maxage,(nyearssel+1):(nyears+proyears)))
V[Vindrest]<-selrecent[Vindrest[,2]]
# F index
Find<-array(rep(Fapical,each=nsim),c(nsim,nyears))
M_ageArray <- array(mean(OM@M), dim=c(nsim, maxage, nyears + proyears))
M2years<-1994:(2016+proyears)
M2ages<-6:20
M_ageArray[,M2ages,M2years-1978+1]<-0.8
recdevs<-read.csv('data/rec devs.csv',header=F)[,1]
procsd<-sd(recdevs)
procmu <- -0.5 * (procsd)^2  # adjusted log normal mean
AC<-acf(recdevs)$acf[2,1,1]
OM@Perr<-rep(procsd,2)
OM@AC=rep(AC,2)
Perr<-array(NA,c(nsim,nyears+proyears+maxage-1))
Perr<-matrix(rnorm(nsim*(maxage+nyears+proyears-1),rep(procmu,maxage+nyears+proyears-1),rep(procsd,maxage+nyears+proyears-1)),nrow=nsim)
Perr[,maxage+(0:(nyearssel-2))]<-rep(recdevs,each=nsim) # generate a bunch of simulations with uncertainty
for (y in 2:(maxage-1)) Perr[, y] <- AC * Perr[, y - 1] +   Perr[, y] * (1 - AC * AC)^0.5
for (y in maxage+(nyears:(nyears + proyears))-1) Perr[, y] <- AC * Perr[, y - 1] +   Perr[, y] * (1 - AC * AC)^0.5
Perr<-exp(Perr)
OM@cpars<-list(V=V,Find=Find,M_ageArray=M_ageArray,Perr=Perr)
OM@seed <- 1001
OMdoc(OM,openFile=FALSE, ntrials=100)
packageVersion(MSEtool)
packageVersion('MSEtool')
packageVersion('DLMtool')
